时间复杂度并不是表示一个程序解决问题需要花多少时间，而是当问题规模扩大后，程序需要的时间长度增长
得有多快。也就是说，对于高速处理数据的计算机来说，处理某一个特定数据的效率不能衡量一个程序的好坏，
而应该看当这个数据的规模变大到数百倍后，程序运行时间是否还是一样，或者也跟着慢了数百倍，或者变慢
了数万倍。不管数据有多大，程序处理花的时间始终是那么多的，我们就说这个程序很好，具有O(1)的时间复
杂度，也称常数级复杂度；数据规模变得有多大，花的时间也跟着变得有多长，这个程序的时间复杂度就是O(n)，
比如找n个数中的最大值；而像冒泡排序、插入排序等，数据扩大2倍，时间变慢4倍的，属于O(n^2)的复杂度。
还有一些穷举类的算法，所需时间长度成几何阶数上涨，这就是O(a^n)的指数级复杂度，甚至O(n!)的阶乘
级复杂度.

“NP问题”，实际上是在探讨NP问题与P类问题的关系。
    显然，所有的P类问题都是NP问题。也就是说，能多项式地解决一个问题，必然能多项式地验证一个问题
    的解——既然正解都出来了，验证任意给定的解也只需要比较一下就可以了。关键是，人们想知道，是否
    所有的NP问题都是P类问题。我们可以再用集合的观点来说明。如果把所有P类问题归为一个集合P中，把
    所有NP问题划进另一个集合NP中，那么，显然有P属于NP。现在，所有对NP问题的研究都集中在一个问
    题上，即究竟是否有P=NP？通常所谓的“NP问题”，其实就一句话：证明或推翻P=NP。
    NPC:
        一个问题A可以约化为问题B的含义即是，可以用问题B的解法解决问题A，或者说，问题A可以“变成”
        问题B。
        《算法导论》上举了这么一个例子。比如说，现在有两个问题：求解一个一元一次方程和求解一个
        一元二次方程。那么我们说，前者可以约化为后者，意即知道如何解一个一元二次方程那么一定能
        解出一元一次方程。我们可以写出两个程序分别对应两个问题，那么我们能找到一个“规则”，按照
        这个规则把解一元一次方程程序的输入数据变一下，用在解一元二次方程的程序上，两个程序总能
        得到一样的结果。这个规则即是：两个方程的对应项系数不变，一元二次方程的二次项系数为0。按
        照这个规则把前一个问题转换成后一个问题，两个问题就等价了。同样地，我们可以说，Hamilton
        回路可以约化为TSP问题(Travelling Salesman Problem，旅行商问题)：在Hamilton回路
        问题中，两点相连即这两点距离为0，两点不直接相连则令其距离为1，于是问题转化为在TSP问题
        中，是否存在一条长为0的路径。Hamilton回路存在当且仅当TSP问题中存在长为0的回路。

时间复杂度分为两种类别：第一种是O(1)、O(n)、O(nlogn)、O(n^2)... O(n^k)。另外一种是O(2^n)、
O(3^n)... O(n!)。后者的复杂度无论如何都远远大于前者。对于第一种复杂度，我们把它叫做多项式级的
时间复杂度，因为它的规模n总是出现在底数的位置上。而对于第二种时间复杂度，我们称之为非多项式级的，
我们一般称其为指数级的复杂度，其复杂度计算机往往不能承受。当我们在解决一个问题时，我们选择的算法
通常都需要是多项式级的复杂度，非多项式级的复杂度需要的时间太多，往往会超时，除非是数据规模非常小。

多项式时间或多项式复杂度
    如一个问题输入有n项，如果解决时间为n或nlogn或n^2或n^3乃至n^100000，那么就可以叫多项式时间，
    但是如果要用2^n的时间，那么就不能叫多项式时间了。时间复杂度为多项式时间的，就叫做具有多项式
    时间复杂度。不是多项式时间算法的算法被称之为“指数时间算法”。
P型问题    Polynomial Solvable
    定义：那些可以在多项式( polynomial )时间内解决的问题，称为P问题。（或：如果一个问题可以找
         到一个能在多项式的时间里解决它的算法，那么这个问题就属于P问题。）
    如果一个问题可以找到一个能在多项式的时间里解决它的算法，那么这个问题就属于P问题。
    对于一个问题，如果可以找到一个解决该问题的算法，且该算法的时间复杂度为多项式时间，则就称这个
    问题属于P问题。其中P是英文单词Polynomial（多项式）的首字母。用书上的话来讲，P问题 就是多
    项式时间内可以被确定型图灵机求解的问题。
    注意:
        提前警告，NP问题不是非P类问题。不要把N理解为非。
NP型问题   Non-determinstic Polynomial Solvable
    定义：给定一个解，我们可以在多项式时间内检查他正确与否的决策问题，为NP问题。
         比如，我要找一个图的哈密顿路径，随便给我一个解，我都可以在多项式时间内检查它是不是哈密
         顿路径。只要形如定义的问题，就是NP问题. 之所以要定义NP问题，是因为通常只有NP问题才可
         能找到多项式的算法。我们不会指望一个连多项式地验证一个解都不行的问题存在一个解决它的多
         项式级的算法. 很显然，所有的P类问题都是NP问题。也就是说，能多项式地解决一个问题，必然
         能多项式地验证一个问题的解——既然正解都出来了，验证任意给定的解也只需要比较一下就可以了。
         关键是，人们想知道，是否所有的NP问题都是P类问题。我们可以再用集合的观点来说明。如果把
         所有P类问题归为一个集合P中，把所有 NP问题划进另一个集合NP中，那么，显然有P属于NP。
         现在，所有对NP问题的研究都集中在一个问题上，即究竟是否有P=NP？通常所谓的“NP问题”，
         其实就一句话：证明或推翻P=NP。
    如果不能判定该问题是否为P问题，但是，提供一个可能解，如果我们可以在多项式时间内验证该解是否
    正确，那么我们就称该问题为NP问题（为Non-deterministic Polynomial）。用书上的话来讲，
    NP问题 就是 多项式时间内可以通过确定型图灵机验证解的问题。
    N就是Non-deterministic ，也就是非确定性问题。什么是非确定性问题呢？有些问题是确定性的解
    法的，比如1到100求和，你只要按照公式推导，按部就班一步步来，就可以得到结果。有些问题，是没
    有现成公式的，是无法按部就班直接地计算出来。比如，找下一个质数的问题。有没有一个公式，你只管
    套用公式，就可以一步步推算出来，下一个质数是多少。答案是没有这样的公式。这种问题的答案，是无
    法直接计算得到的，只能通过间接的“猜算”来得到结果，先猜一个结果，然后去验证，如果正确，运气不
    错，如果不正确，再猜。这就是非确定性问题。如果验证那个猜测值所用的时间是多项式时间，那么我们
    就是这个问题是NP问题。

    P就是能在多项式时间内解决的问题，NP就是能在多项式时间验证答案正确与否的问题。说一个问题是NP
    的，并不是说这个问题不能在多项式时间内解决，而是说目前为止，可能暂时尚未找到解法。所以，再强
    调一遍，NP不是P的否定。NP与P不是对立的，因为所有的P问题都是NP问题。

    NP问题不是非P类问题。NP问题是指可以在多项式的时间里验证一个解的问题。NP问题的另一个定义是，
    可以在多项式的时间里猜出一个解的问题。比方说，我RP很好，在程序中需要枚举时，我可以一猜一个准。
    现在某人拿到了一个求最短路径的问题，问从起点到终点是否有一条小于100个单位长度的路线。它根据
    数据画好了图，但怎么也算不出来，于是来问我：你看怎么选条路走得最少？我说，我RP很好，肯定能
    随便给你指条很短的路出来。然后我就胡乱画了几条线，说就这条吧。那人按我指的这条把权值加起来一
    看，嘿，神了，路径长度98，比100小。于是答案出来了，存在比100小的路径。别人会问他这题怎么做
    出来的，他就可以说，因为我找到了一个比100小的解。在这个题中，找一个解很困难，但验证一个解很
    容易。验证一个解只需要O(n)的时间复杂度，也就是说我可以花O(n)的时间把我猜的路径的长度加出来。
    那么，只要我RP好，猜得准，我一定能在多项式的时间里解决这个问题。我猜到的方案总是最优的，不满
    足题意的方案也不会来骗我去选它。这就是NP问题。
    当然有不是NP问题的问题，即你猜到了解但是没用，因为你不能在多项式的时间里去验证它。下面我要举
    的例子是一个经典的例子，它指出了一个目前还没有办法在多项式的时间里验证一个解的问题。很显然，
    前面所说的Hamilton回路是NP问题，因为验证一条路是否恰好经过了每一个顶点非常容易。但我要把问
    题换成这样：试问一个图中是否不存在Hamilton回路。这样问题就没法在多项式的时间里进行验证了，
    因为除非你试过所有的路，否则你不敢断定它“没有Hamilton回路”。 Hamiltonian path

NP-Complete问题，也叫做NP完全问题 -->  背包问题
    定义：NP-c问题是这样的一类问题，首先他是属于NP的，而且他是NP问题里面最难解决的问题。难到什
         么程度？只要其中某个问题可以在P时间内解决，那么所有的NP问题就都可以在P时间内解决了。
         既然所有的NP问题都能约化成NPC问题，那么只要任意一个NPC问题找到了一个多项式的算法，那
         么所有的NP问题都能用这个算法解决了，NP也就等于P 了。因此，给NPC找一个多项式算法太不
         可思议了。
         1970年，cook同志发明了cook定理，找到了第一个NP-c问题，SAT(Satisfiability)问题
         （逻辑电路问题）。他是这么说的，如果SAT问题可以在P时间解决，那么所有的NP问题都可以在
         P时间内解决。
         有了第一个NPC问题后，一大堆NPC问题就出现了，因为再证明一个新的NPC问题只需要将一个已
         知的NPC问题约化到它就行了。后来，Hamilton 回路成了NPC问题，TSP问题也成了NPC问题，
         其他还有图染色问题、背包问题等。现在被证明是NPC问题的有很多，任何一个找到了多项式算法
         的话所有的NP问题都可以完美解决了。因此说，正是因为NPC问题的存在，P=NP变得难以置信。

    1) 它得是一个NP问题；
    2) 所有的NP问题都可以约化到它。
    “可约化”是指的可“多项式地”约化(Polynomial-time Reducible)，即变换输入的方法是能在多项
    式的时间里完成的
    所有的NP问题都可以多项式规约到它的问题。简单来讲就是NP中最难的问题，只要这个有多项式解，
    那么其余的NP都有, 即N=NP。
     NP中所有问题都可以在多项式时间内规约至某一子类问题，称这一类子问题为NP-Complete。因此，
     NP-Complete是NP的一个子集。直觉上说，就是NP问题中最难的一类子问题。因为给定一个NP问题A，
     只要可以多项式时间内解决任意一个NP-Complete问题B，那么就可以通过多项式的时间将A问题转化
     为B问题进行求解，使得求解A问题仍具有多项式复杂度。

     任取NP类中的一个问题，再任取NP完全类中的一个问题，则一定存在一个具有多项式时间复杂性的算法，
     可以把前者转变成后者。也就是说，对于任意一个NP问题 和 任意一个NP完全问题，总是存在一个多项
     式时间算法，可以把这个NP问题转化为指定的NP完全问题。这就表明，只要能证明NP完全问题中存在一
     个问题是属于P类的，那么就证明了NP类中的所有问题都是P类的，即证明了NP=P。不过，现在还没有
     被证明出来。归根结底，就是要证明P问题是否是NP问题的真子集，谁知道呢？

     目前已知的NP完全性问题就有2000多个，在图上定义的许多组合优化问题是NP完全性问题，如货郎问题、
     调度问题、最大团问题、最大独立集合问题、Steiner树问题、背包问题、装箱问题等，遇到这类问题时，
     通常从以下几个方面来考虑，并寻求解决办法：
         (1) 动态规划法：较高的解题效率。
         (2) 分枝限界法： 较高的解题效率。
         (3) 概率分析法： 平均性能很好。
         (4) 近似算法： 近似解代替最优解。
         (5)启发式算法：根据具体问题的启发式搜索策略在求解，在实际使用可能很有效，但有时很难说清它的道理。

NP-Hard问题
    满足NPC问题定义的第二条但不一定要满足第一条（就是说，NP-Hard问题要比NPC问题的范围广）。


NPC
    Travelling Sales Man, Knapsack, 3D matching,
