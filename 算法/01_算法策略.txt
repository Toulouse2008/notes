算法设计策略
分治算法
    把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子
    问题可以简单的直接求解，原问题的解即子问题的解的合并.
    将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之
    Decrease and conquer
        - 迭代
            优点
            缺点
        - 递归
            分析
                递归跟踪    recursion trace
            使用递归要注意的有两点:
                1)递归就是在过程或函数里面调用自身;
                2)在使用递归时,必须有一个明确的递归结束条件,称为递归出口.
            递归分为两个阶段:
                1)递推:把复杂的问题的求解推到比原问题简单一些的问题的求解;
                2)回归:当获得最简单的情况后,逐步返回,依次得到复杂的解.
            优点: 减少代码量, 代码更简洁清晰，可读性更好
            缺点: 递归调用函数,浪费空间; 递归太深容易造成堆栈的溢出,并且有可能会有一系列的重
                 复计算, 递归算法的执行效率相对较低.

    Divide and conquer
        二分法
    可分治解决的经典问题
        1）二分搜索
        2）大整数乘法
        3）Strassen矩阵乘法
        4）棋盘覆盖
        5）合并排序
        6）快速排序
        7）线性时间选择
        8）最接近点对问题
        9）循环赛日程表
        10）汉诺塔


动态规划算法  dynamic programming
    每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，
    这种多阶段最优化决策解决问题的过程就称为动态规划。
    将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求
    解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优
    的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。
    由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其
    不同阶段的不同状态保存在一个二维数组中。

    与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的
    (即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解)

    能采用动态规划求解的问题的一般要具有3个性质：
        1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，
            即满足最优化原理。
        2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后
            的过程不会影响以前的状态，只与当前状态有关。
        3）有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。
            该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相
            比就不具备优势

    设计过程
        1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的
            阶段一定要是有序的或者是可排序的，否则问题就无法求解。
        2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。
            当然，状态的选择要满足无后效性。
        3)确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶
            段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事
            实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。
        4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。

        一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。
        实际应用中可以按以下几个简化的步骤进行设计：
            （1）分析最优解的性质，并刻画其结构特征。
            （2）递归的定义最优解。
            （3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值
            （4）根据计算最优值时得到的信息，构造问题的最优解

    经典问题
        多段图问题
        关键路径问题
        Floyd(弗洛伊德）算法
        最长公共子序列问题
        0/1背包问题

贪心算法    greedy
    在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的
    仅是在某种意义上的局部最优解。
    注意:
        贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状
        态以后的过程不会影响以前的状态，只与当前状态有关。

    贪心算法的基本思路：
        1.建立数学模型来描述问题。
        2.把求解的问题分成若干个子问题。
        3.对每一子问题求解，得到子问题的局部最优解。
        4.把子问题的解局部最优解合成原来解问题的一个解。

    经典问题
        一般背包问题
        霍夫曼树
        最小代价生成树问题（Prim算法、Kruskal算法）
        Dijkstra算法

回溯算法    backtracking
    回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足
    求解条件时，就“回溯”返回，尝试别的路径
    回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不
    优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个
    状态的点称为“回溯点”。

    经典问题
        n-皇后问题
        子集和数问题
        图的着色问题
        哈密顿环问题

分支限界
    类似于回溯法，也是一种在问题的解空间树T上搜索问题解的算法。但在一般情况下，分支限界法与回溯
    法的求解目标不同。回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是
    找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即
    在某种意义下的最优解。

    经典问题
        15迷问题
        带时限作业排序

随机化算法
    (1)线性同余法
    (2)平方取中法
    (3)乘同余法
    (4)混合同余法
