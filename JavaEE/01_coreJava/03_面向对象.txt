Java 面向对象三大特性
    a:封装
        (1)隐藏实现细节，提供公共的访问方式
        (2)好处：
            A:隐藏实现细节，提供公共的访问方式
            B:提高代码的复用性
            C:提高代码的安全性
        (3)设计原则
            把不想让外界知道的实现细节给隐藏起来，提供公共的访问方式
        (4)private是封装的一种体现。
            封装：类，方法，private修饰成员变量
    b:继承
        定义: 把多个类中相同的成员给提取出来定义到一个独立的类中。然后让这多个类和该独立的类产
             生一个关系，这多个类就具备了这些内容。这个关系叫继承。

        格式: 关键字 extends
            A:用关键字extends表示
            B:格式：
                class 子类名 extends 父类名 {}
        好处：
            A:提高了代码的复用性
            B:提高了代码的维护性
            C:让类与类产生了一个关系，是多态的前提
        弊端：
            A:让类的耦合性增强。这样某个类的改变，就会影响其他和该类相关的类。
                原则：低耦合，高内聚。
                耦合：类与类的关系
                内聚：自己完成某件事情的能力
            B:打破了封装性
        继承的特点
            A:Java中类只支持单继承, 注意: 接口可以多继承!!!
            B:Java中可以多层(重)继承(继承体系)
        注意事项：
            A:子类不能继承父类的私有成员
            B:子类不能继承父类的构造方法，但是可以通过super去访问
            C:不要为了部分功能而去继承
        什么时候使用继承呢?
            A:继承体现的是：is a的关系。
            B:采用假设法
        Java继承中的成员关系
            A:成员变量
                a:子类的成员变量名称和父类中的成员变量名称不一样，这个太简单
                b:子类的成员变量名称和父类中的成员变量名称一样，这个怎么访问呢?
                    子类的方法访问变量的查找顺序：
                        在子类方法的局部范围找，有就使用。
                        在子类的成员范围找，有就使用。
                        在父类的成员范围找，有就使用。
                        找不到，就报错。
            B:构造方法
                a:子类的构造方法默认会去访问父类的无参构造方法
                    是为了子类访问父类数据的初始化
                b:父类中如果没有无参构造方法，怎么办?
                    子类通过super去明确调用带参构造
                    子类通过this调用本身的其他构造，但是一定会有一个去访问了父类的构造
                    让父类提供无参构造
            C:成员方法
                a:子类的成员方法和父类中的成员方法名称不一样，这个太简单
                b:子类的成员方法和父类中的成员方法名称一样，这个怎么访问呢?
                    通过子类对象访问一个方法的查找顺序：
                        在子类中找，有就使用
                        在父类中找，有就使用
                        找不到，就报错
    c:多态
        定义: 同一个对象(事物)，在不同时刻体现出来的不同状态。
        前提：
    		A:要有继承关系。
    		B:要有方法重写。
    			其实没有也是可以的，但是如果没有这个就没有意义。
    				动物 d = new 猫();
    				d.show();
    				动物 d = new 狗();
    				d.show();
    		C:要有父类引用指向子类对象。
    			父 f =  new 子();

        多态中的成员访问特点：由于成员方法存在方法重写，所以它运行看右边。
    		A:成员变量    不能多态调用
    			编译看左边，运行看左边。
    		B:构造方法
    			创建子类对象的时候，访问父类的构造方法，对父类的数据进行初始化。
    		C:成员方法
    			编译看左边，运行看右边。
    		D:静态方法    不能多态调用，属于类的
    			编译看左边，运行看左边。
    			(静态和类相关，算不上重写，所以，访问还是左边的)



成员变量和局部变量的区别
	(1)在类中的位置不同
		成员变量：类中方法外
		局部变量：方法定义中或者方法声明上
	(2)在内存中的位置不同
		成员变量：在堆中
		局部变量：在栈中
	(3)生命周期不同
		成员变量：随着对象的创建而存在，随着对象的消失而消失
		局部变量：随着方法的调用而存在，随着方法的调用完毕而消失
	(4)初始化值不同
		成员变量：有默认值
		局部变量：没有默认值，必须定义，赋值，然后才能使用

static 关键字
    可以修饰成员变量和成员方法

    特点：
        A:随着类的加载而加载
        B:优先与对象存在
        C:被类的所有对象共享
            这其实也是我们判断该不该使用静态的依据。
            举例：饮水机和水杯的问题思考
        D:可以通过类名调用
            既可以通过对象名调用，也可以通过类名调用，建议通过类名调用。
    静态的内存图
        静态的内容在方法区的静态区
    静态的注意事项；
        A:在静态方法中没有this对象
        B:静态只能访问静态(代码测试过)

静态变量和成员变量的区别
    A:所属不同
        静态变量：属于类，类变量
        成员变量：属于对象，对象变量，实例变量
    B:内存位置不同
        静态变量：方法区的静态区
        成员变量：堆内存
    C:生命周期不同
        静态变量：静态变量是随着类的加载而加载，随着类的消失而消失
        成员变量：成员变量是随着对象的创建而存在，随着对象的消失而消失
    D:调用不同
        静态变量：可以通过对象名调用，也可以通过类名调用
        成员变量：只能通过对象名调用
匿名对象
	(1)没有名字的对象
	(2)应用场景
		A:调用方法，仅仅只调用一次的时候。
		b:可以作为实际参数传递。

构造方法
    格式：
		A:方法名和类名相同
		B:没有返回值类型，连void都不能有
		C:没有返回值

		思考题：构造方法中可不可以有return语句呢?
		可以。而是我们写成这个样子就OK了：return;
		其实，在任何的void类型的方法的最后你都可以写上：return;

	       构造方法的注意事项
        		A:如果我们没写构造方法，系统将提供一个默认的无参构造方法
        		B:如果我们给出了构造方法，系统将不再提供默认构造方法
        			如果这个时候，我们要使用无参构造方法，就必须自己给出。
        			推荐：永远手动自己给出无参构造方法。
    this 关键字
        (1)代表当前类的引用对象
        记住：哪个对象调用方法，该方法内部的this就代表那个对象
        (2)this的应用场景：
            A:解决了局部变量隐藏成员变量的问题
            B:其实this还有其他的应用，明天讲解

问题： 代码：Student s = new Student();做了哪些事情?(理解)
	(1)把Student.class文件加载到内存
	(2)在栈内存为s开辟空间
	(3)在堆内存为学生对象申请空间
	(4)给学生的成员变量进行默认初始化。null,0
	(5)给学生的成员变量进行显示初始化。林青霞,27
	(6)通过构造方法给成员变量进行初始化。刘意,30
	(7)对象构造完毕，把地址赋值给s变量
