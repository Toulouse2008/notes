final
    可以修饰类，方法，变量

    特点：
        final可以修饰类，该类不能被继承。
        final可以修饰方法，该方法不能被重写。(覆盖，复写)
        final可以修饰变量，该变量不能被重新赋值。因为这个变量其实常量。

    面试题：final修饰局部变量的问题
		基本类型：基本类型的值不能发生改变。
		引用类型：引用类型的地址值不能发生改变，但是，该对象的堆内存的值是可以改变的。
    final修饰变量的初始化时机
    		A:被final修饰的变量只能赋值一次。
    		B:在构造方法完毕前。(非静态的常量)

        由于继承中方法有一个现象：方法重写。
    	所以，父类的功能，就会被子类给覆盖调。
    	有些时候，我们不想让子类去覆盖掉父类的功能，只能让他使用。
    	这个时候，针对这种情况，Java就提供了一个关键字：final

抽象类 abstract
    一个类如果没有抽象方法，可不可以定义为抽象类?如果可以，有什么意义?
        A:可以。
        B:不让创建对象。

        abstract不能和哪些关键字共存?
        private	冲突
        final	冲突
        static	无意义

    特点：
		A:抽象类和抽象方法必须用abstract关键字修饰
		B:抽象类中不一定有抽象方法,但是有抽象方法的类必须定义为抽象类
		C:抽象类不能实例化
			因为它不是具体的。
			抽象类有构造方法，但是不能实例化?构造方法的作用是什么呢?
			用于子类访问父类数据的初始化
		D:抽象的子类
			a:如果不想重写抽象方法，该子类是一个抽象类。
			b:重写所有的抽象方法，这个时候子类是一个具体的类。

		抽象类的实例化其实是靠具体的子类实现的。是多态的方式。
			Animal a = new Cat();

    抽象方法
        只能声明，不能实现，即使是 {} 也不行，强制要求子类中实现。
